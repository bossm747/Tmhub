{"pageProps":{"post":{"title":"Advancing Open Domain Question Answering with RocketQA","date":"2022-01-04","slug":"2022-01-03_RocketQA","author":"Nan Wang, Shubham Saboo","content":"<h2 id=\"overview\">Overview</h2>\n<p>We discussed building an Open Domain Question Answering (ODQA) system with Jina in our <a href=\"https://jina.ai/blog/2021-11-29-odqa-part-1/\">previous post</a>. The two-stage pipeline consisting of a retriever and reader is widely used in practice.</p>\n<p>As the reader part is relatively developed, most of the recent research focuses on the retriever part, which is in the process of development. <a href=\"https://arxiv.org/pdf/2010.08191.pdf\">RocketQA</a> is one of the successful attempts in this direction. Until July 2021, it was the top algorithm on the <a href=\"https://microsoft.github.io/MSMARCO-Passage-Ranking-Submissions/leaderboard/\">MS MARCO leaderboard</a>. Recently, RocketQA released its code and models. We are proud to partner with RocketQA, which will allow you to use the RocketQA pre-trained models directly from Jina Hub.</p>\n<p>In this post, We'll introduce the idea of RocketQA and show you how to use it to build an ODQA using Jina.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure1.svg\" alt=\"\"></span></p>\n<h2 id=\"where-does-dpr-fail\">Where does DPR Fail?</h2>\n<p>As one of the dense-vector methods, DPR (Dense Passage Retrieval) is the first attempt to show that dense vector retrieval can outperform the term-based methods with a simple training procedure.</p>\n<p>Negative sampling is one of the most important methods used in DPR. The DPR proposed using gold passages (correct question-answer pairs) from a mini-batch as a positive sample and <code>BM-25</code> to generate the negative samples. To be more specific, given a positive sample, DPR uses <code>BM-25</code> to retrieve the most matched passages as negative samples that do not contain the right answers. By feeding both the positive and negative samples to the training procedure, the dual encoder model learns to create a vector space. In this vector space, relevant questions and answers will have smaller distances than the irrelevant pairs.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure2.svg\" alt=\"\"></span></p>\n<p>This method works well in general. But after a close look, we will notice that some of the negative samples are false negatives because of the noisy training data. For example, <strong>\"DNA is made up of molecules called nucleotides\"</strong> is a correct answer, but it is considered a negative sample.</p>\n<p>Another issue with negative sampling in DPR is that the negative samples are generated from the same batch as the positive samples. This setting is very different from the actual use cases. In practice, both the matched and the mismatched passages are retrieved from the whole corpus instead of a set of selected passages. This mismatch leads to the situation where the model was trained with some simple negative samples but was asked to distinguish hard negative samples during inference.</p>\n<h2 id=\"how-does-rocketqa-work\">How does RocketQA work?</h2>\n<p>RocketQA introduced a cross-attention encoder to rerank the retrieved results and a four-step pipeline to improve the training procedure. Let's understand both of them in detail:</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure3.svg\" alt=\"\"></span></p>\n<h3 id=\"cross-encoder\">Cross Encoder</h3>\n<p>Besides the dual encoders for independently encoding the questions and passages, RocketQA uses another transformer-based model to learn the cross-correlation between the questions and the passages. This model is called a cross encoder, which is more precise due to the cross attention to the question and the passages. However, it requires more computations and can only be applied to a limited number of candidates.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure4.svg\" alt=\"\"></span></p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure5.svg\" alt=\"\"></span></p>\n<h3 id=\"four-step-training-procedure\">Four-step Training Procedure</h3>\n<p>RocketQA uses a four-step procedure to train the dual encoder and the cross encoder using an end-to-end pipeline.</p>\n<ol>\n<li>RocketQA uses cross-batch sampling to generate hard negative samples. This solves the issue of in-batch sampling of DPR so that the model gets aware of the negative samples, which are hard to distinguish.</li>\n<li>In this step, RocketQA trains the cross encoder. Instead of using <code>BM25</code> for generating negative samples as in step 1. RocketQA uses the dual encoder trained from step 1 to filter out the false positive ones from the hard negative samples. Another benefit of this is to finetune the cross encoder with the data distribution learned from the dual encoder.</li>\n<li>In this step, RocketQA retrains the dual encoder. To filter out the false-positive samples, RocketQA uses both the dual encoder from step 1 and the cross encoder from step 2 to further remove the data noises.</li>\n<li>In this step, together with the cross encoder from step 2, and the dual encoder from step 3 it further filters the noise in the data. As both the cross encoder and the dual encoder have been trained, RocketQA lets you use them for generating the training data from the unlabeled dataset. This augmented data is combined with the labelled data to finetune the dual encoder.</li>\n</ol>\n<p>After training, the dual encoder and cross encoder is used to retrieve the passages. The cross encoder will return a confidence score for each pair of questions and answers.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2022-01-03_RocketQA/figure6.svg\" alt=\"\"></span></p>\n<h2 id=\"comparison-between-conventional-dpr-and-rocketqa\">Comparison between Conventional DPR and RocketQA</h2>\n<p>Using an example, the following table will illustrate the advantages of RocketQA over the conventional DPR model:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>Question</strong></th><th><strong>DPR</strong></th><th><strong>RocketQA</strong></th></tr></thead><tbody><tr><td>What is DNA made of?</td><td>DNA is what makes us; from the colour of our eyes to the colour of our skin. Without DNA, it would be impossible for us to exist.</td><td><mark> DNA is made of the nitrogen basses cytosine, guanine, adenine, and thymine, phosphates, the sugar deoxyribose, and is all held together by hydrogen bonds. </mark></td></tr><tr><td></td><td>DNA contains the instructions for making you. How you look, what blood type you have, even your tendency to get some diseases. It is found inside the nucleus in just about every single cell of your body. In this lab, you'll break away the membrane around the cell and its nucleus so that you can see your very own DNA. Materials.</td><td><mark> DNA is made up of molecules called nucleotides. Each nucleotide contains a phosphate group, a sugar group and a nitrogen base. </mark> The four types of nitrogen bases are adenine (A), thymine (T), guanine (G) and cytosine (C)</td></tr><tr><td></td><td>DNA is a double helix formed by base pairs attached to a sugar-phosphate backbone. DNA, or deoxyribonucleic acid, is the hereditary material in humans and almost all other organisms. Nearly every cell in a persons body has the same DNA. Most DNA is located in the cell nucleus (where it is called nuclear DNA), but a small amount of DNA can also be found in the mitochondria (where it is called mitochondrial DNA or mtDNA). <mark> The information in DNA is stored as a code made up of four chemical bases: adenine (A), guanine (G), cytosine (C), and thymine (T).</mark> The structure of the double helix is somewhat like a ladder, with the base pairs forming the ladder rungs and the sugar and phosphate molecules forming the vertical sidepieces of the ladder. An important property of DNA is that it can replicate, or make copies of itself.</td><td>DNA is made up of molecules called nucleotides. Each nucleotide contains a phosphate group, a sugar group and a nitrogen base. The four types of nitrogen bases are adenine (A), thymine (T), guanine (G) and cytosine (C). The order of these bases is what determines DNA's instructions, or genetic code.</td></tr></tbody></table>\n<h2 id=\"using-rocketqa-with-jina\">Using RocketQA with Jina</h2>\n<p>RocketQA is available at <a href=\"https://hub.jina.ai/\">Jina Hub</a>, and it integrates seamlessly with Jina. We create a <code>Flow</code> for indexing the <code>Document</code> in the code below. The Document passages are stored in the <code>.tags['para']</code> field. You can pass the <code>.tags['title']</code> to improve accuracy. In the index Flow, we use <code>RocketQADualEncoder</code> to encode the passages into vectors and store them with <code>SimpleIndexer</code>.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> jina <span class=\"hljs-keyword\">import</span> Document, Flow\n\n<span class=\"hljs-comment\"># Creating a Document object</span>\ndoc = Document(tags={<span class=\"hljs-string\">'title'</span>: title, <span class=\"hljs-string\">'para'</span>: para})\n\n<span class=\"hljs-comment\"># Creating the indexing flow with RockectQADualEncoder and SimpleIndexer</span>\nflow = (Flow()\n        .add(uses=<span class=\"hljs-string\">'jinahub+docker://RocketQADualEncoder'</span>,\n        uses_with={<span class=\"hljs-string\">'use_cuda'</span>: <span class=\"hljs-literal\">False</span>})\n        .add(uses=<span class=\"hljs-string\">'jinahub://SimpleIndexer'</span>,\n        uses_metas={<span class=\"hljs-string\">'workspace'</span>: <span class=\"hljs-string\">'workspace_rocketqa'</span>}))\n\n<span class=\"hljs-comment\"># Indexing the Documents using the flow</span>\n<span class=\"hljs-keyword\">with</span> flow:\n   flow.post(on=<span class=\"hljs-string\">'/index'</span>, inputs=[doc,])\n</code></pre>\n<p>For querying, we will create a query flow as shown below. Besides the <code>RocketQADualEncoder</code>, we also use <code>RocketQAReranker</code> for reranking the results which implements the cross encoder part in RocketQA.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> jina <span class=\"hljs-keyword\">import</span> Flow\n\n<span class=\"hljs-comment\"># Creating the Query flow </span>\nflow = (Flow(use_cors=<span class=\"hljs-literal\">True</span>, protocol=<span class=\"hljs-string\">'http'</span>, port_expose=<span class=\"hljs-number\">45678</span>)\n    .add(uses=<span class=\"hljs-string\">'jinahub+docker://RocketQADualEncoder'</span>,\n        uses_with={<span class=\"hljs-string\">'use_cuda'</span>: <span class=\"hljs-literal\">False</span>})\n    .add(uses=<span class=\"hljs-string\">'jinahub://SimpleIndexer'</span>,\n        uses_metas={<span class=\"hljs-string\">'workspace'</span>: <span class=\"hljs-string\">'workspace_rocketqa'</span>},\n        uses_with={<span class=\"hljs-string\">'match_args'</span>: {<span class=\"hljs-string\">'limits'</span>: <span class=\"hljs-number\">10</span>}})\n    .add(uses=<span class=\"hljs-string\">'jinahub+docker://RocketQAReranker'</span>,        \n         uses_with={<span class=\"hljs-string\">'model'</span>: <span class=\"hljs-string\">'v1_marco_ce'</span>, <span class=\"hljs-string\">'use_cuda'</span>: <span class=\"hljs-literal\">False</span>}))\n \n <span class=\"hljs-comment\"># Opening the query flow for incoming queries</span>\n <span class=\"hljs-keyword\">with</span> flow:\n     <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n         question = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">'Question?: '</span>)\n         <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> question:\n             <span class=\"hljs-keyword\">break</span>\n        f.post(on=<span class=\"hljs-string\">'/search'</span>, inputs=Document(text=question),\n        on_done=print_answers)\n</code></pre>\n<p>You can find the complete source code <a href=\"https://github.com/jina-ai/example-odqa\">here</a>.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>In this post, we have given a short introduction to RocketQA and shown you how to use it with Jina. The ODQA field is an active topic attracting more and more researchers. At Jina AI, we are committed to reducing the friction between academic research and their real-world applications by making state-of-the-art frameworks accessible to all.</p>\n<p>Stay tuned for more updates and Happy searching!</p>\n<h2 id=\"references\">References</h2>\n<ul>\n<li><a href=\"https://hub.jina.ai/executor/27h1qsmc\">RocketQADualEncoder</a></li>\n<li><a href=\"https://hub.jina.ai/executor/ao0cuqe8\">RocketQAReranker</a></li>\n<li><a href=\"../blog/2021-11-29-odqa-part-1/\">Building Open Domain QA System with Jina</a></li>\n</ul>","coverImage":"/assets/images/blog/2022-01-03_RocketQA/cover.png","tags":["odqa","qa chatbot"],"sanitize":false,"gfm":true}},"__N_SSG":true}