{"pageProps":{"post":{"title":"Introducing DocArray - A type agnostic data structure!","description":"This blog post will introduce DocArray, define its advantages, and help you to understand its usage.","date":"2022-01-15","slug":"2022-01-13_DocArray","author":"Shubham Saboo, Jyoti Bisht","content":"<h2 id=\"overview\">Overview</h2>\n<p>For data scientists and engineers, speed is important along with accuracy. For accuracy, we built <a href=\"https://github.com/jina-ai/finetuner\">Finetuner</a>, which lets you finetune  neural networks to achieve top performance on downstream tasks. Concerning speed, Jina was already fast, but now it's even faster. That's all down to DocArray - the perfect scalable data structure for deep learning. <code>DocArray</code> has been created to remove all the shortcomings in existing data structures, especially for ML and data science-related tasks. <a href=\"https://docarray.jina.ai/get-started/what-is/#comparing-to-alternatives\">Here</a> is a comparison of <code>DocArray</code> with other data structures.</p>\n<h2 id=\"installation\">Installation </h2>\n<p><code>DocArray</code> is included with Jina 3.0 and above, and it can be accessed after installation. You can install it:</p>\n<ol>\n<li>Via Pip (no extra dependency installed): <code>pip install docarray</code></li>\n<li>Via conda (no extra dependency installed): <code>conda install -c conda-forage docarray</code></li>\n<li>Full install: <code>pip install \"docarray[full]\"</code></li>\n</ol>\n<p>For more details on installation, please refer to this <a href=\"https://docarray.jina.ai/#install\">documentation</a>.</p>\n<h2 id=\"features\">Features </h2>\n<p><code>DocArray</code> is the first step towards standardizing a data structure for machine learning and data science. The aim of <code>DocArray</code> is to provide a single, robust, efficient, and powerful data structure for all your data processing needs. It comes packed with the following features:</p>\n<ul>\n<li>\n<p><strong>Easy to use</strong>: <code>DocArray</code> is completely independent of Jina. It can be used to handle unstructured data without any prior knowledge of Jina’s framework. </p>\n</li>\n<li>\n<p><strong>Support for multiple data types</strong>: <code>DocArray</code> supports all kinds of data including text, image, audio, video, and data types like ndarray, JSON, or Pandas dataframe.</p>\n</li>\n<li>\n<p><strong>Easy operations</strong>: Sharing data over a network is easier with <code>DocArray</code> since it allows serialization and deserialization of data ensuring  network packets are transmitted fast and not lost. Not only this, it's now easier to create, vectorize and embed Documents without external processing.</p>\n</li>\n<li>\n<p><strong>Ultra-fast</strong>: <code>DocArray</code> is much faster than the previous <code>DocumentArray</code> that was built into Jina core. We conducted tests on 100,000 <code>Document</code>s/<code>DocumentArray</code>s averaged over 5 repetitions, and the results speak for themselves:</p>\n</li>\n</ul>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"https://docarray.jina.ai/_images/speedup-vs2.svg\" alt=\"image\"></span></p>\n<ul>\n<li>\n<p><strong>Neural Search Ready</strong>: DocArray is a one-stop solution for all your data pre-processing needs. It comes pre-loaded with basic functionalities like <code>.embed()</code>, <code>.match()</code>, etc. to ensure easy compatibility with Jina core and letting you build neural search solutions in no time.</p>\n</li>\n<li>\n<p><strong>Less overhead for networking</strong>: Now being independent, DocArray has fewer layers and allows better access. DocArray lets you interoperate with other frameworks very easily.</p>\n</li>\n</ul>\n<h2 id=\"operations-on-docarray\">Operations on DocArray</h2>\n<p><code>DocArray</code> has two components: <code>Document</code>, and <code>DocumentArray</code>. <code>Document</code> is the basic data type in Jina, and every piece of data, be it text, audio, video, etc is converted into a <code>Document</code> for further processing. A <code>DocumentArray</code> is a group of <code>Document</code>s. <code>DocArray</code> allows users to manipulate and work with the data stored in <code>Document</code>s and <code>DocumentArray</code>s. Let’s look at them in detail:</p>\n<h3 id=\"document\">Document</h3>\n<ul>\n<li>\n<p><strong>Construction</strong></p>\n<ol>\n<li>Without any attributes:</li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\ndoc = Document()\n</code></pre>\n<ol start=\"2\">\n<li>With attributes:</li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\ndoc = Document(parameter)\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>Nested data: This is all about Documents inside Documents. When we talk about nesting, the important thing to understand is granularity and adjacency:</p>\n<p>a. <strong>Granularity</strong>: nesting Documents vertically. This is achieved by the\n<code>.chunks</code> attribute.</p>\n<p>b. <strong>Adjacency</strong>: nesting Documents horizontally. This is achieved by the\n<code>.matches</code> attribute. </p>\n<p>To see these in action and know more about nesting data in DocArray, please <a href=\"https://docarray.jina.ai/fundamentals/document/nested/\">see here</a>.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\ndoc = Document(<span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">\"one\"</span>, chunks=[Document(<span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">\"two\"</span>)])\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>Serialization</strong>: <code>DocArray</code> makes it really easy to send and receive Documents and it is designed to be \"ready-to-wire\". Serialization is supported for JSON, bytes, dict, and protobuf, and the code for all of them can be found <a href=\"https://docarray.jina.ai/fundamentals/document/serialization/#serialize\">here</a>.</p>\n</li>\n<li>\n<p><strong>Embeddings</strong>: Embeddings are multi-dimensional representations of Documents. The Document's <code>.embedding</code> attribute contains its vector embeddings. Examples and sample usage can be found <a href=\"https://docarray.jina.ai/fundamentals/document/embedding/\">here</a>.</p>\n</li>\n<li>\n<p><strong>Visualization</strong>: Visualization is very important with image and video data. <code>DocArray</code> helps you achieve this using the <code>.plot()</code> method. If you want to see the organization of your nested data, you can use the <code>.summary()</code> method. </p>\n</li>\n</ul>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"https://docarray.jina.ai/_images/doc-plot-in-jupyter.png\" alt=\"image\"></span></p>\n<h3 id=\"documentarray\">DocumentArray</h3>\n<ul>\n<li><strong>Constructing a <code>DocumentArray</code></strong>: You can construct a <code>DocumentArray</code> using a single file, multiple local files, a list of Documents, and even from empty Documents. A simple <code>DocumentArray</code> would look something like this:</li>\n</ul>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> DocumentArray\ndocs = DocumentArray()\n</code></pre>\n<p>That's not all. You can perform <a href=\"https://docarray.jina.ai/fundamentals/documentarray/construct/\">many other operations while creating a DocumentArray</a>:</p>\n<ul>\n<li>\n<p><strong>Serialization</strong>: Serialization of <code>DocumentArray</code> is similar to that of a <code>Document</code>. You can also serialize a <code>DocumentArray</code>  to be sent across a network, in bytes, JSON, cloud, base64, Protobuf, list, or dataframe. An in-depth overview of all the processes is listed <a href=\"https://docarray.jina.ai/fundamentals/documentarray/serialization/#from-to-bytes\">here</a>.</p>\n</li>\n<li>\n<p><strong>Access elements</strong>: <code>DocumentArray</code> elements can be accessed as easily as Python lists. <code>DocumentArray</code> lets you  access deeply-nested Documents by id, ellipses, multiple ids, boolean masks, or nested structure, and the usage can be seen here.</p>\n</li>\n<li>\n<p><strong>Nearest neighbors</strong>: <code>DocArray</code> also makes it easy to find nearest neighbors within Documents in the DocumentArray. If the <code>.embeddings()</code> attribute is set for a <code>DocumentArray</code>, we can use the <code>match()</code> method for finding the nearest neighbour <code>Document</code>s. </p>\n</li>\n<li>\n<p><strong>Evaluate matches</strong>: You can evaluate the result using the <code>evaluate()</code> method of <code>DocArray</code>. The results are stored in the <code>evaluations()</code> field of the <code>Document</code>s. You can get more information about the performance such as average precision, reciprocal rank, f1 score, etc in this document.</p>\n</li>\n</ul>\n<h2 id=\"examples\">Examples</h2>\n<p>Since we talked about the different features of <code>DocArray</code> and what makes it the most suitable data structure for deep learning, now it's time to look at the capabilities of <code>DocArray</code> in action. Let's look at two examples of <code>DocArray</code> for two different data types:</p>\n<h3 id=\"manipulating-text-with-docarray\">Manipulating Text with DocArray</h3>\n<p>Let's see a simple example of representing text in <code>DocArray</code>. Representing text is as simple as creating an instance of <code>Document</code> and adding the text to it. The <code>Document</code> supports data in any language. In this first step, data is converted into a <code>Document</code> to be ready for further processing.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\n\n<span class=\"hljs-comment\">#convert a simple sentence into a Document in Jina </span>\ndoc = Document(text=<span class=\"hljs-string\">'hello, world'</span>)\n\n<span class=\"hljs-comment\"># convert a sentence in Hindi to a Document in Jina</span>\ndoc = Document(text=’👋\tनमस्ते दुनिया!’)\n</code></pre>\n<p>Diving a bit deeper, let's see how we can build a very simple text matching function. The idea is to input a query sentence, match it with sentences in our dataset, and return the matched sentences.</p>\n<p>First, we need to load the dataset from a URL, convert it into text, and put it into a <code>Document</code>. The dataset is the e-book of Pride and Prejudice that can be found <a href=\"https://www.gutenberg.org/files/1342/1342-0.txt\">here</a>.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\ndoc = Document(uri=<span class=\"hljs-string\">\"https://www.gutenberg.org/files/1342/1342-0.txt\"</span>).load_uri_to_text()\n</code></pre>\n<p>Next, since our dataset is an amalgamation of long sentences, we need to break it into smaller chunks that can be converted into a DocumentArray. We split the sentences using the '\\n' symbol i.e. whenever a new line is encountered, we store that sentence as a <code>Document</code> in the <code>DocumentArray</code>.</p>\n<pre><code class=\"hljs language-python\">docs = DocumentArray(Document(text = s.strip()) <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> doc.text.split(<span class=\"hljs-string\">'\\n'</span>) <span class=\"hljs-keyword\">if</span> s.strip())\n</code></pre>\n<p>Next comes the vectorization of features (i.e. we need to convert our features into indices in a vector/matrix). The features in this example become the embeddings of each <code>Document</code> in our <code>DocumentArray</code>. There are many ways to do this but, a faster and space-efficient way is to use feature hashing. It works by taking the features, applying a hash function that can hash the values and return them as indices. But, <code>DocArray</code> saves us from the computation, and using <strong>feature hashing</strong> is as easy as a single line of code:</p>\n<pre><code class=\"hljs language-python\">docs.apply(<span class=\"hljs-keyword\">lambda</span> doc: doc.embed_feature_hashing())\n</code></pre>\n<p>Finally, we take our query sentence, convert it into a <code>Document</code>, vectorize it and then match it with the vectors of the <code>Document</code>s in the <code>DocumentArray</code>s. We take the query sentence as \"she entered the room\" from Pride and Prejudice and try to fetch similar sentences.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># query sentence </span>\nquery = (Document(text=<span class=\"hljs-string\">\"she entered the room\"</span>).embed_feature_hashing().match(docs, limit=<span class=\"hljs-number\">5</span>, exclude_self=<span class=\"hljs-literal\">True</span>, \nmetric=<span class=\"hljs-string\">\"jaccard\"</span>, use_scipy=<span class=\"hljs-literal\">True</span>))\n\n<span class=\"hljs-comment\"># print the results</span>\n<span class=\"hljs-built_in\">print</span>(query.matches[:, (<span class=\"hljs-string\">'text'</span>, <span class=\"hljs-string\">'scores__jaccard'</span>)])\n</code></pre>\n<p>Here are the arguments used in the <code>.match()</code> method:</p>\n<ul>\n<li><code>limit</code> : It specifies the number of results to be returned. In our example, we specified it to be 5, so 5 sentences will be returned.</li>\n<li><code>exclude_self</code>: If set to True, the sentence won’t be matched to itself. Otherwise, it will match itself and return the query sentence as one of the results.</li>\n<li><code>metric</code>: It defines which metric is used for calculating the nearest neighbors. We use the <a href=\"https://en.wikipedia.org/wiki/Jaccard_index\">jaccard</a> metric in this example.</li>\n<li><code>use_scipy</code>: Framework is automatically chosen depending on the embeddings. Here, we use scipy for better processing.</li>\n</ul>\n<h3 id=\"manipulating-audio-with-docarray\">Manipulating Audio with DocArray</h3>\n<p>Besides text, we can even manipulate audio files using <code>DocArray</code>. In this example, we will reverse an audio file. The first step is to convert an audio file (.wav file in this example) into a <code>Document</code> by loading it and then converting it into an audio blob. Then we can reverse this blob which in turn will reverse the audio. You can listen to the input and output files for this examples <a href=\"https://docarray.jina.ai/datatypes/audio/#example\">here</a>.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> docarray <span class=\"hljs-keyword\">import</span> Document\ndoc = Document(uri=<span class=\"hljs-string\">\"hello.wav\"</span>).load_uri_to_audio_blob()\ndoc.blob = doc.blob[::-<span class=\"hljs-number\">1</span>]\ndoc.save_audio_blob_to_file(<span class=\"hljs-string\">\"elloh.wav\"</span>)\n</code></pre>\n<p>Manipulating different data types and working with powerful tools like <code>DocArray</code> adds to the speed of building deep learning applications. You can find examples of all the data types <a href=\"https://docarray.jina.ai/datatypes/\">here</a>.</p>\n<h2 id=\"summary\">Summary</h2>\n<p><code>DocArray</code> closely aligns with Python's list, thus making it super easy and intutive for developers to get started. Behind the simple syntax, DocArray comes with numerous outstanding capabilities compared to Python's list. It expands from one-dimensional data types like text to multidimensional complex data types like images, audio, etc. It also lets you perform a lot of data processing tasks out-of-the-box with its simple abstracted functions. Data professionals will agree that efficient understanding and pre-processing of data is a key to building scalable, fast AI applications.</p>\n<h2 id=\"references\">References</h2>\n<ul>\n<li><a href=\"https://docarray.jina.ai/\">DocArray documentation</a></li>\n<li><a href=\"https://github.com/jina-ai/docarray\">DocArray Github</a></li>\n</ul>","coverImage":"/assets/images/blog/2022-01-13_DocArray/docarray-banner.png","tags":["DocsArray","Release"],"sanitize":false,"gfm":true}},"__N_SSG":true}