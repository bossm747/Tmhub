{"pageProps":{"post":{"title":"Building In-Video Visual Content Search with Jina","description":"In this blog post, we will see how to create a search system capable of searching the in-video content without supplement text.","date":"2021-12-15","slug":"2021-12-15_in-video_visual_content","author":"Nan Wang","content":"<h2 id=\"overview\">Overview</h2>\n<p>Videos are one of the most popular ways to consume data today. Whether it's live streams of our favourite music artists or recorded tutorial videos, we watch them all.</p>\n<p>Perhaps you came across a music video of your favourite artist while browsing YouTube. However, you can't recall the video's name, title, or song. In that case, you only have an image in mind; that image can be of the artist holding a guitar and singing.</p>\n<p>Now you can just explain the image scenario to Youtube’s search engine, and it will magically come up with the resulting video. Today’s search systems are intelligent enough to retrieve data with just a hint of information. Even if you enter <em>“XYZ holding a guitar”</em>, Youtube's search powered by state-of-the-art deep learning models will be able to come up with some results.</p>\n<p>Now imagine you having the capability to create such robust search systems for your internal applications, and that too in a matter of hours! But how would you do that?</p>\n<p>That’s where <a href=\"https://hub.jina.ai/\"><strong>Jina Hub</strong></a> comes in! It lets you use the best open-source models with a single line of code, and that combined with the core Jina framework allows you to create magic!</p>\n<p>In this blog post, we will see how to create a search system capable of searching the in-video content without supplement text.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2021-12-15_in-video_visual_content/visual_search_interface.gif\" alt=\"\"></span></p>\n<p align=\"center\">\nFig 1. In-video Visual Search Interface\n</p>\n<h2 id=\"flow-approach\">Flow Approach</h2>\n<p>We don’t have any textual information about the video in this example. So we cannot match the query directly with the text information of the video in the form of subtitles. We need to find a way of matching text to videos. We know that videos are made of frames/images arranged in a sequential order to form a video. Using this concept, we can build our use case. We can find related frames similar to the query text and return the videos containing these frames as output.</p>\n<p>Normally, every video comprises of three components - audio, video and text. In this example, we will work only with images. If video consists of only text or a static image forming one unique frame, then our use case would not work as we are leveraging the movement of those frames. Also, one more shortcoming of this tutorial is the ability to extend to multiple frames. It means that if you enter <em>“XYZ holding a guitar and then signing an autograph for a boy in a white t-shirt”</em>, this search query cannot be captured in a single frame and hence, is beyond the scope of this tutorial.</p>\n<p>We want a deep learning model that can encode both query text and video frames in the same semantic space for our use case. Therefore, we will use pre-trained cross-modal models from <a href=\"https://hub.jina.ai/\"><strong><strong>Jina Hub</strong></strong></a>!</p>\n<h3 id=\"executors-from-jina-hub\">Executors from Jina Hub</h3>\n<p>To encode video frames and query text into the same space, we will use the pre-trained <a href=\"https://github.com/openai/CLIP\">CLIP Model</a> from OpenAI. We will use the image and text encoding part of the CLIP model to calculate the embeddings for this example application.</p>\n<p><strong>What is CLIP?</strong></p>\n<p>CLIP stands for Contrastive Language-Image Pre-Training. It is trained to learn visual concepts from natural languages with the help of text snippets and image pairs from the internet. It can perform Zero-Shot Learning by encoding text labels and images in the same semantic space and creating the standard embedding for both modalities.</p>\n<p><strong>Why CLIP?</strong></p>\n<p>CLIP works very well for our use case of searching for video content. Let’s say we enter the search text <em>\"this is a guitar\"</em>, the CLIP text model will encode it into a vector. Similarly, the CLIP image model can encode an image of a guitar and a violin into the same vector space. Encoding both the text and images into the same space allows us to calculate the distance between the text vector and the image vector to provide relevant results. In this example, the distance between the text <em>\"this is a guitar\"</em>, and the image of the guitar will be smaller than the distance between the same text and the image of the violin.</p>\n<p>For this example, we will use SimpleIndexer as our indexer as it allows us to store both vectors and meta-data information in one shot. For searching through the indexed data, we will use the built-in <code>match</code> function of <code>DocumentArrayMemap</code>.</p>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2021-12-15_in-video_visual_content/working_of_clip.svg\" alt=\"\"></span></p>\n<p align=\"center\">\nFig 2. Working of CLIP Model\n</p>\n<h3 id=\"building-the-flow\">Building the Flow</h3>\n<p>Let’s go through each of the steps in the Flow in sequential order to understand what’s happening behind the scenes:</p>\n<ul>\n<li><code>frame_extractor</code>: It extracts the frames from the videos allowing us to work with the image data type encoded in the same space as the query text.</li>\n<li><code>image_encoder</code>: It uses the CLIP image encoder to encode the extracted frames into the common vector space.</li>\n<li><code>text_encoder</code>: It uses the CLIP text encoder to encode the query text into the same vector space where the frames are encoded.</li>\n<li><code>indexer</code>: It uses SimpleIndexer to index the encoded text and image data for querying</li>\n<li><code>ranker</code>: It ranks the query results based on the degree of similarity in the vector space.</li>\n</ul>\n<p class=\"image-only\"><span class=\"image-wrapper\"><img src=\"/assets/images/blog/2021-12-15_in-video_visual_content/application_flow.svg\" alt=\"\"></span></p>\n<p align=\"center\">\nFig 3. Application Flow\n</p>\n<p>We have seen how the different Flow components work together to process the query text and generate the response. Now, let’s understand the two types of requests in detail - <code>index</code> and <code>query</code>.</p>\n<h3 id=\"index\">Index</h3>\n<p>For requests to the <code>/index</code> endpoint, the indexing flow uses three different Executors - <code>VideoLoader</code>, <code>CLIPImageEncoder</code> and <code>SimpleIndexer</code> to pre-process and index the data. It follows a sequential flow of data as discussed in the below steps:</p>\n<ul>\n<li>The input to Flow is Documents with video URIs stored in the <code>uri</code> attribute. These can be files on the cloud or your local machine. After receiving the raw input, control goes to the <code>VideoLoader</code> that extracts the frames from the videos and stores them as image arrays in the <code>blob</code> attribute of the chunks.</li>\n<li>The processed frames are passed onto the <code>CLIPImageEncoder</code> that calculates the 512-dimensional embedding vector for each chunk using the CLIP model for images.</li>\n<li>Finally, the control is passed to <code>SimpleIndexer</code> that stores and indexes all the Documents within the memory map.</li>\n</ul>\n<h3 id=\"query\">Query</h3>\n<p>For requests to the <code>/search</code> endpoint, also known as query endpoint, the query flow uses three different Executors - <code>CLIPTextEncoder</code>, <code>SimpleIndexe</code>r, and <code>SimpleRanker</code> to pre-process the query text and match it with the indexed data. It follows a sequential flow of data as discussed in the below steps:</p>\n<ul>\n<li>The user input gets stored in the <code>text</code> attribute of the Document. After that, the control goes to <code>CLIPTextEncoder</code>, which converts the query text into vector embedding.</li>\n<li>After getting the embeddings for the search query, the <code>SimpleIndexer</code> compares the query embedding vector with the indexed data to retrieve the top-K nearest neighbours.</li>\n<li>In the end, the control goes to the <code>SimpleRanker</code> that ranks the results and shows the most relevant ones.</li>\n</ul>\n<blockquote>\n<p><strong>Tips</strong>: Find more information at Jina Hub about <a href=\"https://hub.jina.ai/executor/livtkbkg\">CLIPTextEncoder</a>, <a href=\"https://hub.jina.ai/executor/0hnlmu3q\">CLIPImageEncoder</a> and <a href=\"https://hub.jina.ai/executor/zb38xlt4\">SimpleIndexer</a>.</p>\n</blockquote>\n<h2 id=\"summary\">Summary</h2>\n<p>In this blog, we learned how to create an intelligent in-video visual content search system by leveraging state-of-the-art opensource models with Jina’s framework. This use case can further be extended to incorporate audio data and video frames to improve the quality of search results. We can use the <a href=\"https://github.com/AndreyGuzhov/AudioCLIP\">AudioCLIP</a> model from OpenAI to generate embeddings for audio in the same semantic space as images and text.</p>\n<p>You can find the application code in the following <a href=\"https://github.com/jina-ai/example-video-search/tree/feat-simple-tutorial\">GitHub Repository</a></p>\n<p>In the future posts, we will cover more about building SOTA search applications by leveraging Jina Hub. Stay tuned and happy Searching!</p>","coverImage":"/assets/images/blog/2021-12-15_in-video_visual_content/banner.png","tags":["video","search"],"sanitize":false}},"__N_SSG":true}