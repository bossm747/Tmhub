{"pageProps":{"post":{"title":"Tutorial: A deep-dive with Executors","date":"2021-07-15","slug":"tutorial-executors","author":"Susana Guzman","content":"<p>Last time we talked about how to create the <a href=\"https://jina.ai/tutorial.html\">hello world chatbot</a>, but we didn't go much into Executors' details. Let's take a look at them now.\nWe will create a simple logger Executor. It will log whatever info from the Documents we pass to it and save it to a file. We will also see how to push our Executor to Hub to use it later.</p>\n<h2>Set-up &#x26; overview</h2>\n<p>We recommend creating a <a href=\"https://docs.python.org/3/tutorial/venv.html\">new python virtual environment</a> to have a clean install of Jina and prevent dependency clashing.</p>\n<p>We can start by installing Jina:</p>\n<pre><code class=\"language-shell\">pip install jina[standard]\n</code></pre>\n<p>For more information on installing Jina, refer to this <a href=\"https://github.com/jina-ai/jina#install\">page</a>.</p>\n<h2>Create your Executor</h2>\n<p>To create your Executor, you just need to run this command in your terminal:</p>\n<pre><code class=\"language-shell\">jina hub new\n</code></pre>\n<p>A wizard will ask you some questions about the Executor. For the basic configuration, you will be asked two things: The Executor's name and where it should be saved. For this tutorial, we will call ours <strong>RequestLogger</strong>. And you can save it wherever you want to have your project. The wizard will ask if you want to have a more advanced configuration, but it is unnecessary for this tutorial.</p>\n<h3>Logger Executor</h3>\n<p>Once we followed the wizard, we have our folder structure ready. We can start working with the <code>executor.py</code>. Open that file, and let's import the following</p>\n<pre><code class=\"language-python\">import os\nimport time\nfrom typing import Dict\n\nfrom jina import Executor, DocumentArray, requests\nfrom jina.logging.logger import JinaLogger\n</code></pre>\n<p>Then we create our class that inherits from the <code>Executor</code> base class. We will call ours <code>RequestLogger</code></p>\n<pre><code class=\"language-python\">class `RequestLogger`(Executor):    \n</code></pre>\n<p>Our Executor will have two methods. One for the constructor and one for the actual logging:</p>\n<pre><code class=\"language-python\">class RequestLogger(Executor):    \n    def __init__(self, **args, **kwargs):\n        #Whatever you need for our constructor\n\n    def log():\n        #Whatever we need for our logging\n</code></pre>\n<p>It could be helpful to specify the number of Documents we want to work with, so we pass this directly in the arguments of our constructor</p>\n<pre><code class=\"language-python\">de __init__(self,\n                default_log_docs: int = 1,      # here you can pass whatever other arguments you need                                                    \n                *args, **kwargs):     \n</code></pre>\n<p>Ok, now we start creating our constructor method. First thing you need to do before any custom logic is this:</p>\n<pre><code class=\"language-python\">super().__init__(*args, **kwargs)\n</code></pre>\n<p>We now set the <code>default_log_docs</code> we got from the arguments:</p>\n<pre><code class=\"language-python\">self.default_log_docs = default_log_docs\n</code></pre>\n<p>For logging, we need to create an instance for the <code>JinaLogger</code>. And we also need to specify the path where to save our file.</p>\n<pre><code class=\"language-python\">self.logger = JinaLogger('req_logger')\nself.log_path = os.path.join(self.workspace, 'log.txt')\n</code></pre>\n<p>And finally, we need to check the path doesn't exist already</p>\n<pre><code class=\"language-python\">if not os.path.exists(self.log_path):\n    with open(self.log_path, 'w'): pass\n</code></pre>\n<p>Ok, that's it for our constructor, by now we should have something like this:</p>\n<pre><code class=\"language-python\">\nclass RequestLogger(Executor):                                                                      # needs to inherit from Executor\n    def __init__(self,\n                default_log_docs: int = 1,                                                          # number of documents to log\n                *args, **kwargs):                                                                   # *args and **kwargs are required for Executor\n        super().__init__(*args, **kwargs)                                                           # before any custom logic\n        self.default_log_docs = default_log_docs\n        self.logger = JinaLogger('req_logger')                                                      # create instance of JinaLogger\n        self.log_path = os.path.join(self.workspace, 'log.txt')                                     # set path to save the log.txt\n        if not os.path.exists(self.log_path):                                                       # check the file doesn't exist already\n            with open(self.log_path, 'w'): pass\n\n</code></pre>\n<p>We can start creating our <code>log</code> method now. First of all, we need the <code>@requests</code> decorator. This is to communicate to the <code>Flow</code> when the function will be called and to which endpoint. We use <code>@requests</code> without any endpoint, so we will call our function on every request:</p>\n<pre><code class=\"language-python\">@requests                                                                                       \n    def log(self,                                                                                   \n            docs: Optional[DocumentArray],\n            parameters: Dict,\n            **kwargs):\n</code></pre>\n<p>It's important to note the arguments here. <strong>It's not possible to redefine the interface of the public methods decorated by <code>@requests</code></strong>. You can't change the name of these arguments. To see exactly which parameters you can use, check our cookbook about <a href=\"https://github.com/jina-ai/jina/blob/master/.github/2.0/cookbooks/Executor.md#method-arguments\">Executors</a>.\nIf you would like to call your <code>log</code> function only on <code>index</code> time, you specify the endpoint with <code>on=</code>, like this:</p>\n<pre><code class=\"language-python\">@requests(on='/index')                                                                                      \n    def log(self,                                                                           \n            Optional[DocumentArray],\n            parameters: Dict,\n            **kwargs):\n</code></pre>\n<p>If you want more information on how to use this decorator, you could check our <a href=\"https://github.com/jina-ai/jina/blob/master/.github/2.0/cookbooks/Executor.md#requests-decorator\">cookobook</a>. In this example, we want to call our <code>log</code> function on every request, so we don't specify any endpoint.</p>\n<p>Now we can add the logic for our function. First, we will print a line that displays some information. And then, we will save the details from our Documents:</p>\n<pre><code class=\"language-python\">self.logger.info('Request being processed...')\n\nnr_docs = int(parameters.get('log_docs', self.default_log_docs))                            # accesing parameters (nr are passed as float due to Protobuf)\n        with open(self.log_path, 'a') as f:\n            f.write(f'request at time {time.time()} with {len(docs)} documents:\\n')\n            for i, doc in enumerate(docs):\n                f.write(f'\\tsearching with doc.id {doc.id}. content = {doc.content}\\n')\n                if i + 1 == nr_docs:\n                    break\n</code></pre>\n<p>Here you can set whatever logic you need for your Executor. By now, your code should look like this:</p>\n<pre><code class=\"language-python\">import os\nimport time\nfrom typing import Dict\n\nfrom jina import Executor, DocumentArray, requests\nfrom jina.logging.logger import JinaLogger\n\n\nclass `RequestLogger`(Executor):                                                                      # needs to inherit from Executor\n    def __init__(self,\n                default_log_docs: int = 1,                                                          # your arguments\n                *args, **kwargs):                                                                   # *args and **kwargs are required for Executor\n        super().__init__(*args, **kwargs)                                                           # before any custom logic\n        self.default_log_docs = default_log_docs\n        self.logger = JinaLogger('req_logger')\n        self.log_path = os.path.join(self.workspace, 'log.txt')\n        if not os.path.exists(self.log_path):\n            with open(self.log_path, 'w'): pass\n\n    @requests                                                                                       # decorate, by default it will be called on every request\n    def log(self,                                                                                   # arguments are automatically received\n            Optional[DocumentArray],\n            parameters: Dict,\n            **kwargs):\n        self.logger.info('Request being processed...')\n\n        nr_docs = int(parameters.get('log_docs', self.default_log_docs))                            # accesing parameters (nr are passed as float due to Protobuf)\n        with open(self.log_path, 'a') as f:\n            f.write(f'request at time {time.time()} with {len(docs)} documents:\\n')\n            for i, doc in enumerate(docs):\n                f.write(f'\\tsearching with doc.id {doc.id}. content = {doc.content}\\n')\n                if i + 1 == nr_docs:\n                    break\n</code></pre>\n<p>And that's it. We have an <code>Executor</code> that takes whatever Documents we pass to it and logs them.</p>\n<p>Ok, and what now? How can you use this in your app?</p>\n<h3>Push your Executor to Hub</h3>\n<p>We could use our Executor directly in our app, but here we will see how to push it to Jina Hub so we can share it with more people, or use it later.\nFor this, you need to open a terminal in the folder of your <code>executor.py</code>, so in this case, open a terminal inside the <code>RequestLogger</code> folder. And there you just need to type:</p>\n<pre><code class=\"language-bash\">jina hub push --public .\n</code></pre>\n<p>This means you will push your Executor publicly to Jina Hub. The last dot means you will use your current path. Once you run that command, you should see something like this:</p>\n<p><img src=\"/assets/images/blog/tutorials/push-executor.png\" alt=\"image\"></p>\n<p>Since we pushed our Executor using the <code>--public</code> flag, the only thing we will use is the ID, which is <code>zsor7fe6</code> in this case.</p>\n<p>So now we have our Executor pushed to Jina Hub, and we can use it via the ID. Let's see how to do that.</p>\n<h3>Use your Executor</h3>\n<p>Let's now create some Flows that can use the Executor we just made. Create an <code>app.py</code> in the same folder as <code>RequestLogger</code>. Now open it and import <code>Flow</code>, <code>DocumentArray</code>, <code>Document</code> before we create our `main function:</p>\n<pre><code class=\"language-python\">from jina import Flow, DocumentArray, Document\n\ndef main():\n    # We'll have our Flows here\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>The Executor we just created logs whatever Documents we pass to it. So we need to create some Documents first. We'll do that on the <code>main()</code></p>\n<pre><code class=\"language-python\">def main():\n    docs = DocumentArray()\n    docs.append(Document(content='I love cats'))                # creating documents\n    docs.append(Document(content='I love every type of cat'))\n    docs.append(Document(content='I guess dogs are ok'))\n</code></pre>\n<p>We have three Documents in one <code>DocumentArray</code>. Now let's create a <code>Flow</code> and add the Executor we created. We will reference it by the ID we got when we pushed it, in my case, it was <code>zsor7fe6</code>, but you change this for the ID you got:</p>\n<pre><code class=\"language-python\">\nflow = Flow().add(                                              \n        uses='jinahub+docker://zsor7fe6',\n        uses_with={                                         # RequestLogger arguments\n            'default_log_docs': 3\n        },\n        volumes='workspace:/internal_workspace',                # mapping local folders to docker instance folders\n        uses_metas={                                        # Executor (parent class) arguments\n            'workspace': '/internal_workspace',                 # this should match the above\n        },\n    )\n</code></pre>\n<p>This seems like plenty of details but let's see them one by one.</p>\n<pre><code class=\"language-python\">uses='jinahub+docker://zsor7fe6',\n</code></pre>\n<p>Here you use <code>uses=</code> to specify the image of your Executor. This will start a Docker container with the image of the Executor we built and deployed in the previous step. So don't forget to change the ID to the correct one.</p>\n<pre><code class=\"language-python\">uses_with={                                         # RequestLogger arguments\n            'default_log_docs': 3\n        },\n</code></pre>\n<p>We need <code>uses_with=</code> to pass the arguments we need. In our case, we have only one argument: <code>default_log_docs</code>. In the constructor of our <code>RequestLogger</code> Executor, we defined the <code>default_log_docs</code> as <code>1</code>, but we override it here with <code>3</code>, so <code>3</code> will be the new value.</p>\n<p>The next line refers to our workspace:</p>\n<pre><code class=\"language-python\">volumes='workspace:/internal_workspace',\n</code></pre>\n<p>Here we are mapping the <code>workspace</code> folder that will be created when we run our app to a folder called <code>internal_workspace</code> in Docker. We do this because our Executor logs the Documents into a file, and we want to save that file on our local disk. If we don't do that, the information would be saved in the Docker container, and you would need to access that container to see files.  To do this, we use <code>volumes=</code> and set it to our internal workspace.</p>\n<p>The last part overrides arguments too, but this time for the Executor's base class:</p>\n<pre><code class=\"language-python\">uses_metas={                                                # Executor (parent class) arguments\n            'workspace': '/internal_workspace',                 # this should match the above\n        },\n</code></pre>\n<p>In our case, the only argument we want to override is the name of the <code>workspace</code>. If you don't do this, a folder with the same name of your Executor class (<code>RequestLogger</code>) would be created, and your information would have been saved there. But since we just mounted our workspace with the name <code>internal_workspace</code> in Docker, we need to make a folder with that same name.</p>\n<p>Ok, we have our <code>Flow</code> ready with the Executor we deployed previously. We can use it now. Let's start by indexing the Documents:</p>\n<pre><code class=\"language-python\">with flow as f:                                                 # Flow is a context manager\n        f.post(\n            on='/index',                                        # the endpoint\n            inputs=docs,                                        # the documents we send as input\n        )\n</code></pre>\n<p>The Executor we created doesn't care about what endpoint is used, so it will perform the same operation no matter what endpoint you specify here. In this example, we set it to <code>on='/index'</code> anyway. Here you could use one for <code>index</code> and another one for <code>query</code> if you need it and your Executor has the proper endpoints.</p>\n<p>So far, your code should look like this:</p>\n<pre><code class=\"language-python\">from jina import Flow, DocumentArray, Document\n\n\ndef main():\n    docs = DocumentArray()\n    docs.append(Document(content='I love cats'))                # creating documents\n    docs.append(Document(content='I love every type of cat'))\n    docs.append(Document(content='I guess dogs are ok'))\n\n    flow = Flow().add(                                          # provide as class name or jinahub+docker URI\n        uses='jinahub+docker://7dne55rj',\n        uses_with={                                         # RequestLogger arguments\n            'default_log_docs': 3\n        },\n        volumes='workspace:/internal_workspace',                # mapping local folders to docker instance folders\n        uses_metas={                                        # Executor (parent class) arguments\n            'workspace': '/internal_workspace',                 # this should match the above\n        },\n    )\n\n    with flow as f:                                             # Flow is a context manager\n        f.post(\n            on='/index',                                        # the endpoint\n            inputs=docs,                                        # the documents we send as input\n        )\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>And if you run this, you will see a new <code>workspace</code> folder created with two other folders inside. One called <code>RequestLogger</code> or whatever name you used in your class. And another folder for the sharding, but we won't talk about that in this tutorial because it's out of scope. Inside the sharding folder called <code>0</code> in this case, you will see a <code>log.txt</code> file. And there you will have the 3 Documents with their information.</p>\n<p><img src=\"/assets/images/blog/tutorials/log.png\" alt=\"image\"></p>\n<p>And that's it! You created an Executor, pushed it to Hub, and used it in your app.</p>\n<p>There are still a lot of concepts to learn. So stay tuned for our following tutorials.</p>\n<p>If you have any issues following this tutorial, you can always get support from our <a href=\"https://slack.jina.ai/\">Slack community</a></p>\n<h2>Community</h2>\n<ul>\n<li><a href=\"https://slack.jina.ai/\">Slack community</a> - a communication platform for developers to discuss Jina.</li>\n<li><a href=\"https://www.linkedin.com/company/jinaai/\">LinkedIn</a> - get to know Jina AI as a company and find job opportunities.</li>\n<li><a href=\"https://twitter.com/JinaAI_\">Twitter</a> - follow us and interact with us using hashtag #JinaSearch.</li>\n<li><a href=\"https://jina.ai\">Company</a> - know more about our company, we are fully committed to open-source!</li>\n</ul>\n<h2>License</h2>\n<p>Copyright (c) 2021 Jina AI Limited. All rights reserved.</p>\n<p>Jina is licensed under the Apache License, Version 2.0. See <a href=\"https://github.com/jina-ai/jina/blob/master/LICENSE\">LICENSE</a> for the full license text.</p>\n","coverImage":"/assets/images/blog/tutorials/jina_executor_tutorial.png"}},"__N_SSG":true}